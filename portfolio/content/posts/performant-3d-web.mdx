---
title: "Building Performant 3D Experiences on the Web"
summary: "A deep dive into optimizing Three.js applications for production, covering rendering techniques, memory management, and mobile performance."
tags: ["WebGL", "Performance", "Three.js", "Tutorial"]
publishedAt: "2024-10-15"
published: true
---

## Introduction

WebGL and Three.js have democratized 3D graphics on the web, but building performant 3D experiences that work across devices remains challenging. After shipping multiple production 3D applications, I've learned valuable lessons about optimization that I want to share.

## The Performance Budget

Before diving into techniques, establish your performance budget:

- **Target:** 60 FPS (16.67ms per frame)
- **Budget breakdown:**
  - JavaScript: 3-4ms
  - Rendering: 8-10ms
  - Browser work: 3-4ms
  - Buffer: 2ms

Monitor these with Chrome DevTools Performance tab.

## Optimization Techniques

### 1. Instanced Rendering

Rendering thousands of similar objects? Use `InstancedMesh`:

```typescript
// ❌ Bad: Individual meshes
const meshes = [];
for (let i = 0; i < 10000; i++) {
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  scene.add(mesh);
  meshes.push(mesh);
}

// ✅ Good: Instanced mesh
const instancedMesh = new THREE.InstancedMesh(
  geometry,
  material,
  10000
);

for (let i = 0; i < 10000; i++) {
  matrix.setPosition(x, y, z);
  instancedMesh.setMatrixAt(i, matrix);
}

instancedMesh.instanceMatrix.needsUpdate = true;
scene.add(instancedMesh);
```

**Impact:** 100x fewer draw calls, 10x faster rendering.

### 2. Geometry Optimization

Reduce vertex count aggressively:

```typescript
// Use LOD (Level of Detail)
const lod = new THREE.LOD();

// High detail (close)
lod.addLevel(highPolyMesh, 0);

// Medium detail
lod.addLevel(mediumPolyMesh, 50);

// Low detail (far)
lod.addLevel(lowPolyMesh, 200);

scene.add(lod);
```

Also consider:
- BufferGeometry instead of Geometry
- Merge static geometries
- Use indexed geometries

### 3. Texture Atlasing

Combine textures to reduce draw calls:

```typescript
// Create atlas
const canvas = document.createElement('canvas');
canvas.width = 2048;
canvas.height = 2048;
const ctx = canvas.getContext('2d')!;

// Pack textures
textures.forEach((img, i) => {
  ctx.drawImage(img, x, y, w, h);
});

const atlasTexture = new THREE.CanvasTexture(canvas);
```

Don't forget to update UVs!

### 4. Frustum Culling

Three.js does this automatically, but you can optimize further:

```typescript
// Manual culling for custom objects
const frustum = new THREE.Frustum();
const cameraViewProjectionMatrix = new THREE.Matrix4();

function updateFrustum() {
  camera.updateMatrixWorld();
  cameraViewProjectionMatrix.multiplyMatrices(
    camera.projectionMatrix,
    camera.matrixWorldInverse
  );
  frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
}

function isVisible(object: THREE.Object3D) {
  return frustum.intersectsObject(object);
}
```

### 5. Shader Optimization

Move calculations to vertex shader when possible:

```glsl
// ❌ Fragment shader (runs per pixel)
varying vec3 vNormal;
void main() {
  vec3 light = normalize(vec3(1.0, 1.0, 1.0));
  float intensity = max(dot(vNormal, light), 0.0);
  gl_FragColor = vec4(vec3(intensity), 1.0);
}

// ✅ Vertex shader (runs per vertex)
attribute vec3 normal;
varying float vIntensity;
void main() {
  vec3 light = normalize(vec3(1.0, 1.0, 1.0));
  vIntensity = max(dot(normal, light), 0.0);
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
```

## Mobile-Specific Optimizations

Mobile GPUs are less powerful—adapt accordingly:

```typescript
const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);

const config = {
  shadowMapEnabled: !isMobile,
  antialias: !isMobile,
  pixelRatio: Math.min(window.devicePixelRatio, isMobile ? 2 : 3),
  maxParticles: isMobile ? 5000 : 50000,
};

const renderer = new THREE.WebGLRenderer({
  antialias: config.antialias,
  powerPreference: 'high-performance',
});

renderer.setPixelRatio(config.pixelRatio);
renderer.shadowMap.enabled = config.shadowMapEnabled;
```

## Memory Management

Dispose properly to avoid memory leaks:

```typescript
function dispose(object: THREE.Object3D) {
  object.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      child.geometry.dispose();

      if (Array.isArray(child.material)) {
        child.material.forEach(m => m.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

// Clean up on unmount
useEffect(() => {
  return () => {
    dispose(scene);
    renderer.dispose();
  };
}, []);
```

## Monitoring Performance

Track metrics in production:

```typescript
const stats = {
  fps: 0,
  frameTime: 0,
  memory: 0,
};

function measurePerformance() {
  const start = performance.now();

  renderer.render(scene, camera);

  stats.frameTime = performance.now() - start;
  stats.fps = 1000 / stats.frameTime;

  // @ts-ignore
  stats.memory = performance.memory?.usedJSHeapSize || 0;

  // Send to analytics
  if (stats.fps < 30) {
    analytics.track('low_fps', stats);
  }
}
```

## Checklist

Before shipping:

- [ ] Profile with Chrome DevTools
- [ ] Test on low-end Android device
- [ ] Measure memory usage over time
- [ ] Verify 60 FPS on target devices
- [ ] Add loading states
- [ ] Implement fallback for unsupported devices
- [ ] Respect prefers-reduced-motion

## Resources

- [Three.js Manual](https://threejs.org/manual/)
- [WebGL Fundamentals](https://webglfundamentals.org/)
- [GPU Gems (free online)](https://developer.nvidia.com/gpugems/gpugems/contributors)

## Conclusion

3D on the web is incredibly powerful, but requires discipline and optimization. Start with a performance budget, measure constantly, and optimize ruthlessly. Your users will thank you with longer sessions and better engagement.

What optimization techniques have worked for you? [Let me know on Twitter](https://twitter.com/roshankhatri)!
